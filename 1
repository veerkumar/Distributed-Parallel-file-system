#include "commons.h"
using namespace std;

class cache_manager {
	public:
        final static cache *obj_cache; 
	mutex mutx_free_list;
	mutex mutx_allocated_list;
	mutex mutx_dirty_list;
	mutex mutx_map_fname_to_chunks;
	vector<cache_block*> free_list;
	vector<cache_block*> allocated_list;
	vector<cache_block*> dirty_list;
	map<string,vector<cache_block*>> map_fname_to_chunks;
// Whenever a file is opened or written, update this list, it will be used in dirty_list harverst
	map<string,vector<string>> map_file_recep; 
        cache_manager() {
                if (obj_cache == NULL) {
                        obj_cache =  new cache();
			 /* add newly allocated in the free list */
			for(int i=0; i<ROW;i++) {
				for(int j=0; j<COLUMN;j++) {
					free_block_list.push_back(&obj_cache->slots[i][j]);
				}
			}
                }
        } 

	cache* get_cache_obj () {
		return obj_cache;
	}

	bool add_to_back_free_list_l (cache_block *cb) {
		mutx_free_list.lock();
		free_list.push_back(cb);
		mutx_free_list.unlock();
	return true;
	}
	bool add_to_front_free_list_l (cache_block *cb) {
		mutx_free_list.lock();
		free_list.insert(free_list.begin(),cb);
		mutx_free_list.unlock();
	return true;
	}

	bool rm_from_free_list_l (cache_block *cb) {
	
	return true;
	}
	
	bool rm_from_free_list_l ( vector<cache_block *>::iterator it) {
		mutx_free_list.lock();
		free_list.erase(it);
		mutx_free_list.unlock();
	return true;
	}

	bool add_to_dirty_list_l (cache_block *cb) {
	return true;
	
	}

	bool rm_from_dirty_list_l (cache_block *cb) {
	return true;
	
	}

	bool add_to_allocated_list_l (cache_block *cb) {
	return true;
	
	}
	
	bool add_to_front_allocated_list_l (cache_block *cb) {
		mutx_allocated_list.lock();
		allocated_list.insert(allocated_list.begin(),cb);
		mutx_allocated_list.unlock();

	return true;
	}

	bool rm_from_allocated_list_l (cache_block *cb) {
	return true;
	}

	bool rm_from_allocated_list_l ( vector<cache_block *>::iterator it) {
		mutx_allocated_list.lock();
		allocated_list.erase(it);
		mutx_allocated_list.unlock();
		return true;
	}

	bool add_to_map_fname_chunks_l (cache_block *cb) {
	 return true;
	}

	bool rm_from_map_fname_chunks_l (string file_name, cache_block* cb) {
		return true;	
	}
};             

class cache {
	public:
		cache_block **slots;

		cache(){
			slots = new cache_block*[ROW];
			for(int i =0; i<ROW;i++) {
				slots[i] = new cache_block[COLUMN];
			}     
		}
}                                                  

class cache_block {
	public:
		bool dirty;
		string file_name;
		int start_index;
		int end_index;
		vector<pair<int,int>> dirty_range; 
		char* data;

		cache_block() {
			dirty = false;
			file_name = "";
			start_index = 0;
			end_index = 0;
			data = new char[BLOCK_SIZE];
		}

		~cache_block(){
			if(data != NULL) {
				delete data;
				dirty_range.clear();
			}
		}

		void clean_cache_block(){
			if (dirty == false) {
				this.file_name.erase();
				this.start_index = 0;
				this.end_index = 0;
				delete data;
				this.data = NULL;
			} else {
#ifdef DEBUG_FLAG
				cout<<"This block is dirty name: " << file_name;
#endif
				return false;
			}
			return true;
		}
}
